# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03-pv-forecast.ipynb (unless otherwise specified).

__all__ = ['estimate_daily_solar_quantiles', 'dts', 'x', 'y', 'rerun_daily_solar_model', 'daily_solar_filename',
           'extract_solar_profile', 'charge_profile']

# Cell
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
import seaborn as sns

from moepy.lowess import quantile_model

from batopt import clean
from .discharge import sample_random_day

import FEAutils as hlp

# Cell
def estimate_daily_solar_quantiles(x, y, x_pred = np.linspace(0, 23.5, 100), **model_kwargs):
    # Fitting the model
    df_quantiles = quantile_model(x, y, x_pred=x_pred, **model_kwargs)

    # Cleaning names and sorting for plotting
    df_quantiles.columns = [f'p{int(col*100)}' for col in df_quantiles.columns]
    df_quantiles = df_quantiles[df_quantiles.columns[::-1]]

    return df_quantiles

dts = df.index.tz_convert('Europe/London')
x = np.array(dts.hour + dts.minute/60)
y = df['pv_power_mw'].values

rerun_daily_solar_model = False
daily_solar_filename = 'daily_solar_quantile_model_results.csv'

if (rerun_daily_solar_model == True) or (daily_solar_filename not in os.listdir(cache_data_dir)):
    df_quantiles = estimate_daily_solar_quantiles(x, y, frac=0.2, num_fits=48, robust_iters=3)
    df_quantiles.to_csv(f'{cache_data_dir}/{daily_solar_filename}')
else:
    df_quantiles = pd.read_csv(f'{cache_data_dir}/{daily_demand_filename}', index_col='x')

# Cell
def extract_solar_profile(s_solar_sample_dt, start_time='00:00', end_time='15:00'):
    dt = str(s_solar_sample_dt.index[0].date())
    solar_profile = s_solar_sample_dt[f'{dt} {start_time}':f'{dt} {end_time}'].values

    return solar_profile

# Cell

def charge_profile(solar_profile, capacity=6, max_charge_rate=2.5, time_unit=0.5):
    charge = 0
    order = np.flip(np.argsort(random_day))
    solution = np.zeros(len(solar_profile))
    for i in order:
        solar_available = np.minimum(solar_profile[i], max_charge_rate)
        solar_available = min(solar_available, (capacity - charge)/time_unit)
        charge += solar_available * time_unit
        solution[i] = solar_available
        if charge > capacity:
            break
    assert(np.sum(time_unit*solution) <= capacity), f"Too much charge: {np.sum(solution)}"
    return solution

for i in range(100):
    random_day = sample_random_day(pv).pipe(extract_solar_profile)
    x = charge_profile(random_day) #Â Note there is sometimes a rounding error here
plt.plot(x)
