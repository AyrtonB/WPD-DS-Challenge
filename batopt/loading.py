# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01-data-loading.ipynb (unless otherwise specified).

__all__ = ['load_training_dataset', 'combine_training_datasets', 'identify_df_dt_entries']

# Cell
def load_training_dataset(raw_data_dir: str, dataset_name: str='demand', parse_dt_idx: bool=True) -> pd.DataFrame:
    allowed_datasets = ['demand', 'pv', 'weather']
    assert dataset_name in allowed_datasets, f"`dataset_name` must be one of: {', '.join(allowed_datasets)} - not {dataset_name}"

    df = pd.concat([pd.read_csv(f) for f in glob.glob(f'{raw_data_dir}/{dataset_name}_*.csv')], ignore_index = True)

    if parse_dt_idx == True:
        assert 'datetime' in df.columns, 'if `parse_dt_idx` is True then `datetime` must be a column in the dataset'

        df['datetime'] = pd.to_datetime(df['datetime'])
        df = df.set_index('datetime')

    return df

# Cell
def combine_training_datasets(raw_data_dir):
    df_combined = pd.DataFrame()

    for dataset_name in ['demand', 'pv', 'weather']:
        df_single_dataset = load_training_dataset(raw_data_dir, dataset_name)

        cols_to_be_overwritten = set(df_combined.columns) - (set(df_combined.columns) - set(df_single_dataset.columns))
        assert len(cols_to_be_overwritten) == 0, f"The following columns exist in multiple datasets meaning data would be overwritten: {', '.join(cols_to_be_overwritten)}"

        df_combined = df_combined.append(df_single_dataset)

    df_combined = df_combined.sort_index()

    return df_combined

# Cell
def identify_df_dt_entries(df_demand, df_pv, df_weather):
    min_dt = min(df_demand.index.min(), df_pv.index.min(), df_weather.index.min())
    max_dt = max(df_demand.index.max(), df_pv.index.max(), df_weather.index.max())

    dt_rng = pd.date_range(min_dt, max_dt, freq='30T')
    df_nulls = pd.DataFrame(index=dt_rng)

    df_nulls['demand'] = df_demand.reindex(dt_rng).isnull().mean(axis=1).astype(int)
    df_nulls['pv'] = df_pv.reindex(dt_rng).isnull().mean(axis=1).astype(int)
    df_nulls['weather'] = df_weather.reindex(dt_rng).ffill(limit=1).isnull().mean(axis=1).astype(int)

    df_entries = 1 - df_nulls

    return df_entries